from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from ytmusicapi import YTMusic
from yt_dlp import YoutubeDL
import uvicorn
import os
import time
import base64
import tempfile

app = FastAPI()

# Allow CORS for frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, restrict to frontend URL
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

ytmusic = YTMusic()

@app.get("/info")
def info():
    return {"status": "ok", "service": "Music Streamer Backend"}

@app.get("/search")
def search(q: str):
    try:
        # Search for songs
        results = ytmusic.search(q, filter="songs", limit=20)
        return results
    except Exception as e:
        print(f"Error in search: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/charts")
def get_charts():
    try:
        # Get charts (trending songs)
        charts = ytmusic.get_charts(country="US")
        songs = charts.get('songs', {}).get('items', [])
        
        # Fallback to search if charts are empty (common in some regions/IPs)
        if not songs:
            print("Charts empty, falling back to search")
            search_results = ytmusic.search("Top 100 global songs", filter="songs", limit=20)
            return search_results
            
        return songs
    except Exception as e:
        print(f"Error in charts: {e}")
        # Final fallback
        try:
             return ytmusic.search("Trending Music", filter="songs", limit=20)
        except:
             return []

# Simple in-memory cache: {video_id: {'url': ..., 'expires': timestamp}}
stream_cache = {}

@app.get("/suggestions")
def get_suggestions(q: str = ""):
    try:
        if not q:
            # Return categories if no query
            return {
                "queries": [],
                "results": [
                    {"title": "Pop", "color": "#8d67ab"},
                    {"title": "Rock", "color": "#e8115b"},
                    {"title": "Hip-Hop", "color": "#bc5906"},
                    {"title": "Electronic", "color": "#477d95"},
                    {"title": "Jazz", "color": "#1e3264"},
                    {"title": "Classical", "color": "#503750"}
                ]
            }
        
        queries = ytmusic.get_search_suggestions(q)
        results = ytmusic.search(q, filter="songs", limit=5)
        
        return {
            "queries": queries,
            "results": results
        }
    except Exception as e:
        print(f"Error getting suggestions: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/artist/{browse_id}")
def get_artist(browse_id: str):
    try:
        artist = ytmusic.get_artist(browse_id)
        return artist
    except Exception as e:
        print(f"Error getting artist: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/related/{video_id}")
def get_related(video_id: str, limit: int = 20):
    try:
        # get_watch_playlist returns a "Radio" mix based on the video_id
        # This is the standard way to get taste-based/similar songs in YouTube Music
        related = ytmusic.get_watch_playlist(video_id, limit=limit)
        tracks = related.get('tracks', [])
        # Return the tracks as the radio queue
        return tracks
    except Exception as e:
        print(f"Error getting radio tracks: {e}")
        return []

def prepare_cookies_file():
    """Prepare cookies file from environment variable"""
    cookies_base64 = os.environ.get('YOUTUBE_COOKIES')
    
    if not cookies_base64:
        print("Warning: No YOUTUBE_COOKIES environment variable found")
        return None
    
    try:
        # Decode base64
        cookies_content = base64.b64decode(cookies_base64).decode('utf-8')
        
        # Create a temporary file that persists
        cookies_file = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt')
        
        # Write cookies with proper Netscape format
        lines = cookies_content.strip().split('\n')
        
        # Ensure header exists
        if not any('Netscape HTTP Cookie File' in line for line in lines[:3]):
            cookies_file.write('# Netscape HTTP Cookie File\n')
            cookies_file.write('# This file was generated by yt-dlp\n\n')
        
        # Write all cookie lines
        for line in lines:
            cookies_file.write(line + '\n')
        
        cookies_file.close()
        
        print(f"‚úÖ Cookies file created at: {cookies_file.name}")
        print(f"‚úÖ Cookies file size: {os.path.getsize(cookies_file.name)} bytes")
        
        # Verify file is readable
        with open(cookies_file.name, 'r') as f:
            cookie_count = sum(1 for line in f if not line.startswith('#') and line.strip())
        print(f"‚úÖ Found {cookie_count} valid cookies")
        
        return cookies_file.name
        
    except Exception as e:
        print(f"‚ùå Error preparing cookies: {e}")
        import traceback
        traceback.print_exc()
        return None

# Prepare cookies once at startup
COOKIES_FILE = prepare_cookies_file()

def try_extract_with_client(url, client_name, cookies_file=None):
    """Try to extract video info with a specific client"""
    ydl_opts = {
        'format': 'bestaudio/best',
        'quiet': True,
        'no_warnings': True,
        'noplaylist': True,
        'extract_flat': False,
        'extractor_args': {
            'youtube': {
                'player_client': [client_name],
                'player_skip': ['configs', 'webpage'],
            }
        }
    }
    
    if cookies_file:
        ydl_opts['cookiefile'] = cookies_file
    
    try:
        with YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            if info and info.get('url'):
                return info
    except Exception as e:
        print(f"  ‚ö†Ô∏è  {client_name} client failed: {str(e)[:100]}")
    
    return None

@app.get("/stream/{video_id}")
def get_stream_url(video_id: str):
    try:
        # Check cache
        if video_id in stream_cache:
            cached = stream_cache[video_id]
            if time.time() < cached['expires']:
                print(f"‚úÖ Serving from cache: {video_id}")
                return cached['data']
            else:
                del stream_cache[video_id]

        print(f"üéµ Processing video: {video_id}")
        url = f"https://www.youtube.com/watch?v={video_id}"
        
        # Try multiple clients in order of success rate
        clients_to_try = [
            ('android_music', COOKIES_FILE),      # Best for music
            ('android', COOKIES_FILE),             # Good general fallback
            ('ios', COOKIES_FILE),                 # iOS music app
            ('mweb', COOKIES_FILE),                # Mobile web
            ('android_music', None),               # Try without cookies
            ('android', None),
        ]
        
        info = None
        successful_client = None
        
        print(f"üîÑ Trying multiple clients for {video_id}...")
        for client, cookies in clients_to_try:
            print(f"  üîß Attempting with {client} client{'(with cookies)' if cookies else '(no cookies)'}")
            info = try_extract_with_client(url, client, cookies)
            if info and info.get('url'):
                successful_client = client
                print(f"  ‚úÖ Success with {client} client!")
                break
        
        if not info or not info.get('url'):
            print(f"‚ùå All clients failed for {video_id}")
            raise HTTPException(
                status_code=503, 
                detail="YouTube is currently blocking requests from this server. This is usually temporary. Try again in a few minutes."
            )
        
        data = {
            "url": info.get('url'),
            "title": info.get('title'),
            "thumbnail": info.get('thumbnail'),
            "artist": info.get('uploader') or info.get('channel') or info.get('artist'),
            "duration": info.get('duration')
        }
        
        # Cache for 45 minutes
        stream_cache[video_id] = {
            'data': data,
            'expires': time.time() + 2700
        }
        
        print(f"‚úÖ Successfully extracted: {data['title']} (via {successful_client})")
        return data
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error in stream: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
