from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from ytmusicapi import YTMusic
from yt_dlp import YoutubeDL
import uvicorn
import os
import time
import base64
import tempfile

app = FastAPI()

# Allow CORS for frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, restrict to frontend URL
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

ytmusic = YTMusic()

@app.get("/info")
def info():
    return {"status": "ok", "service": "Music Streamer Backend"}

@app.get("/search")
def search(q: str):
    try:
        # Search for songs
        results = ytmusic.search(q, filter="songs", limit=20)
        return results
    except Exception as e:
        print(f"Error in search: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/charts")
def get_charts():
    try:
        # Get charts (trending songs)
        charts = ytmusic.get_charts(country="US")
        songs = charts.get('songs', {}).get('items', [])
        
        # Fallback to search if charts are empty (common in some regions/IPs)
        if not songs:
            print("Charts empty, falling back to search")
            search_results = ytmusic.search("Top 100 global songs", filter="songs", limit=20)
            return search_results
            
        return songs
    except Exception as e:
        print(f"Error in charts: {e}")
        # Final fallback
        try:
             return ytmusic.search("Trending Music", filter="songs", limit=20)
        except:
             return []

# Simple in-memory cache: {video_id: {'url': ..., 'expires': timestamp}}
stream_cache = {}

@app.get("/suggestions")
def get_suggestions(q: str = ""):
    try:
        if not q:
            # Return categories if no query
            return {
                "queries": [],
                "results": [
                    {"title": "Pop", "color": "#8d67ab"},
                    {"title": "Rock", "color": "#e8115b"},
                    {"title": "Hip-Hop", "color": "#bc5906"},
                    {"title": "Electronic", "color": "#477d95"},
                    {"title": "Jazz", "color": "#1e3264"},
                    {"title": "Classical", "color": "#503750"}
                ]
            }
        
        queries = ytmusic.get_search_suggestions(q)
        results = ytmusic.search(q, filter="songs", limit=5)
        
        return {
            "queries": queries,
            "results": results
        }
    except Exception as e:
        print(f"Error getting suggestions: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/artist/{browse_id}")
def get_artist(browse_id: str):
    try:
        artist = ytmusic.get_artist(browse_id)
        return artist
    except Exception as e:
        print(f"Error getting artist: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/related/{video_id}")
def get_related(video_id: str, limit: int = 20):
    try:
        # get_watch_playlist returns a "Radio" mix based on the video_id
        # This is the standard way to get taste-based/similar songs in YouTube Music
        related = ytmusic.get_watch_playlist(video_id, limit=limit)
        tracks = related.get('tracks', [])
        # Return the tracks as the radio queue
        return tracks
    except Exception as e:
        print(f"Error getting radio tracks: {e}")
        return []

def prepare_cookies_file():
    """Prepare cookies file from environment variable"""
    cookies_base64 = os.environ.get('YOUTUBE_COOKIES')
    
    if not cookies_base64:
        print("Warning: No YOUTUBE_COOKIES environment variable found")
        return None
    
    try:
        # Decode base64
        cookies_content = base64.b64decode(cookies_base64).decode('utf-8')
        
        # Create a temporary file that persists
        cookies_file = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt')
        
        # Write cookies with proper Netscape format
        lines = cookies_content.strip().split('\n')
        
        # Ensure header exists
        if not any('Netscape HTTP Cookie File' in line for line in lines[:3]):
            cookies_file.write('# Netscape HTTP Cookie File\n')
            cookies_file.write('# This file was generated by yt-dlp\n\n')
        
        # Write all cookie lines
        for line in lines:
            cookies_file.write(line + '\n')
        
        cookies_file.close()
        
        print(f"‚úÖ Cookies file created at: {cookies_file.name}")
        print(f"‚úÖ Cookies file size: {os.path.getsize(cookies_file.name)} bytes")
        
        # Verify file is readable
        with open(cookies_file.name, 'r') as f:
            cookie_count = sum(1 for line in f if not line.startswith('#') and line.strip())
        print(f"‚úÖ Found {cookie_count} valid cookies")
        
        return cookies_file.name
        
    except Exception as e:
        print(f"‚ùå Error preparing cookies: {e}")
        import traceback
        traceback.print_exc()
        return None

# Prepare cookies once at startup
COOKIES_FILE = prepare_cookies_file()

@app.get("/stream/{video_id}")
def get_stream_url(video_id: str):
    try:
        # Check cache
        if video_id in stream_cache:
            cached = stream_cache[video_id]
            if time.time() < cached['expires']:
                print(f"‚úÖ Serving from cache: {video_id}")
                return cached['data']
            else:
                del stream_cache[video_id]

        print(f"üéµ Processing video: {video_id}")
        
        # Configure yt-dlp options with Android client to bypass SABR
        ydl_opts = {
            # Use Android client which doesn't have SABR issues
            'extractor_args': {
                'youtube': {
                    'player_client': ['android', 'web'],
                    'player_skip': ['webpage', 'configs'],
                }
            },
            'format': 'bestaudio/best',
            'quiet': True,
            'no_warnings': True,
            'noplaylist': True,
            'extract_flat': False,
            'geo_bypass': True,
            'nocheckcertificate': True,
        }
        
        # Add cookies if available
        if COOKIES_FILE and os.path.exists(COOKIES_FILE):
            ydl_opts['cookiefile'] = COOKIES_FILE
            print(f"‚úÖ Using cookies file: {COOKIES_FILE}")
        else:
            print("‚ö†Ô∏è  No cookies file available")
        
        url = f"https://www.youtube.com/watch?v={video_id}"
        
        try:
            with YoutubeDL(ydl_opts) as ydl:
                print(f"üì• Extracting info for: {url}")
                info = ydl.extract_info(url, download=False)
                
                if not info or not info.get('url'):
                    raise HTTPException(status_code=500, detail="Could not extract stream URL")
                
                data = {
                    "url": info.get('url'),
                    "title": info.get('title'),
                    "thumbnail": info.get('thumbnail'),
                    "artist": info.get('uploader') or info.get('channel'),
                    "duration": info.get('duration')
                }
                
                # Cache for 50 minutes (URLs typically expire after 1 hour)
                stream_cache[video_id] = {
                    'data': data,
                    'expires': time.time() + 3000
                }
                
                print(f"‚úÖ Successfully extracted: {data['title']}")
                return data
                
        except Exception as e:
            error_msg = str(e)
            print(f"‚ùå Extraction failed: {error_msg}")
            
            # Provide helpful error messages
            if "Sign in to confirm" in error_msg or "bot" in error_msg:
                raise HTTPException(
                    status_code=403, 
                    detail="YouTube bot detection triggered. Cookies may be invalid or expired."
                )
            elif "Video unavailable" in error_msg:
                raise HTTPException(status_code=404, detail="Video not available")
            elif "Private video" in error_msg:
                raise HTTPException(status_code=403, detail="Video is private")
            elif "Requested format is not available" in error_msg:
                # Try one more time with different client
                print("‚ö†Ô∏è  Retrying with iOS client...")
                ydl_opts['extractor_args']['youtube']['player_client'] = ['ios', 'android']
                try:
                    with YoutubeDL(ydl_opts) as ydl_retry:
                        info = ydl_retry.extract_info(url, download=False)
                        if info and info.get('url'):
                            data = {
                                "url": info.get('url'),
                                "title": info.get('title'),
                                "thumbnail": info.get('thumbnail'),
                                "artist": info.get('uploader') or info.get('channel'),
                                "duration": info.get('duration')
                            }
                            stream_cache[video_id] = {
                                'data': data,
                                'expires': time.time() + 3000
                            }
                            print(f"‚úÖ Retry successful: {data['title']}")
                            return data
                except:
                    pass
                raise HTTPException(status_code=404, detail="No playable formats found for this video")
            else:
                raise
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error in stream: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
